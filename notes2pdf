#!/bin/bash

# Initialize the IFS as default and store it
IFS=
oIFS=$IFS

# Output line number where error occurs in script
function report_err
{
	echo "Error on line $1"
}

# This function parses and formats bullet lists
# Bullet levels are denoted with indentations
# and any text immediately following a * is treated
# as the bullet "icon" 
#	Ex: '*a.' in the note file becomes 'a.' in the PDF
function list
{
	local file="$1"
	local pi=-1
	local cnt=-1
	local psh=0

	local close=0

	local first style

	while IFS=':' read -r tnum line; do
		if [[ "$line" != "LSTS" ]] && [[ "$line" != "LSTE" ]]; then
			if [ $pi -lt $tnum ]; then
				for i in `seq 0 $pi`; do
					echo -en "\t"
				done
		
				echo "\\begin{itemize}"
				close=$((close+1))
			fi

			if [ $pi -gt $tnum ]; then
				for i in `seq 0 $pi`; do
					echo -en "\t"
				done

				if [ $psh -eq 1 ]; then
					echo -en "\t"
					psh=0
				fi

				echo "\\end{itemize}"
				close=$((close-1))
			fi
			
			first=$(echo $line | sed 's/^[ \t]*//' | cut -d' ' -f1)
			if [ ${#first} -gt 1 ]; then
				style=${first:1}
				line=$(echo $line | sed 's/\*\(.*\) /\\item['"$style"']{/;s/[[:space:]]*$//')
			else
				line=$(echo $line | sed 's/* /\\item{/;s/[[:space:]]*$//')
			fi
			line="$line}"
			
			echo -e "\t$line"

			if [ $pi -gt $tnum ] || [ $pi -eq -1 ]; then
				cnt=0
			elif [ $pi -lt $tnum ]; then
				cnt=1
			fi
	
			pi=$tnum
		fi
	done< <(awk '/LSTS/{flag=1}/LSTE/{print; flag=0}flag' $file | awk '{ match($0, /^[\t]*/); printf("%d:%s\n", RLENGTH, $0); }')

	while [ $close -gt 0 ]; do
		for i in `seq 0 $((close-2))`; do
			echo -en "\t"
		done

		echo "\\end{itemize}"

		close=$((close-1))
	done
}

# This function formats TBL blocks
# TBLS:cols:title is parsed and formatted first
# The first column is formatted as a column title row
function table
{
	local file="$1"
	local title cols
	local ctitle=0
	while IFS= read -r line; do
		if [[ "$line" == "TBLS"* ]]; then
			cols=`cut -d':' -f2 <<< $line`
			title=`cut -d':' -f3 <<< $line`
			echo "\\begin{center}"
			echo -n "\\begin{tabular}{ |"
			IFS=' '
			for i in `seq 1 $cols | tr '\n' '\ '`; do
				echo -n "c| "
			done | sed 's/ c/c/g'
			echo "}"

			echo "\\hline"
			echo "\\multicolumn{$cols}{|c|}{$title} \\\\"
			echo "\\hline"
			ctitle=1
		elif [[ "$line" != "TBLE" ]]; then
			line=$(echo -n $line | tr -s '[ \t]' '\t' | sed 's/\t/ \& /g')
			echo -e "\t$line \\\\\\\\"
			if [ $ctitle -eq 1 ]; then
				echo -e "\t\\\\hline"
				echo -e "\t\\\\hline"
				ctitle=0
			fi
		else
			echo -e "\\\\hline\n\\\\end{tabular}\n\\\\end{center}"
		fi
	done< <(awk '/TBLS/{flag=1}/TBLE/{print; flag=0}flag' $1)
}

# This function is used with equation block parsing
function get_line_count
{
	local file start end num cnt
	file="$1"
	start="$2"
	end="$3"
	num=$4

	sed -n '/'"$start"'/{:a;N;/'"$end"'/!ba;x;s/^/x/;/^x\{'"$num"'\}$/{x;p;q};x}' $file > out
	cnt=`wc -l < out`
	rm out

	echo $((cnt-2))
}

# Isolate frc() from within a line
function isolate_frc
{
	local l="$1"
	local o c d

	if [[ "$l" != "frc("* ]]; then
		l=$(echo $l | sed 's/frc(/ frc(/' | cut -d' ' -f 2-)
	fi

	IFS=
	l=$(echo $l | sed 's/ \+/\+/;s/\+ /\+/;s/\+/_plus/')
	l=$(echo $l | sed 's/ \*/\*/;s/\* /\*/;s/\*/_times/')
	l=$(echo $l | sed 's/ \//\//;s/\/ /\//;s/\//_divide/')

	o=$(echo $l | awk '{ split($0, chars, ""); o = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { o++ } } print o }')
	c=$(echo $l | awk '{ split($0, chars, ""); c = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { c++ } } print c }')

	if [ $c -gt $o ]; then
		d=$((c-o))
		while [ $d -gt 0 ]; do
			l=$(echo $l | sed 's/\(.*\))/\1/')
			d=$((d-1))
		done
	fi
	
	IFS=
	l=$(echo $l | sed 's/_plus/\+/')
	l=$(echo $l | sed 's/_times/\*/')
	l=$(echo $l | sed 's/_divide/\//')
	echo $l
}

# Parses through frc() and formats all frc() into proper LaTeX
function parse_frc
{
	local l="$1"

	while [[ "$l" == *"/"* ]]; do
		l=$(echo $l | sed 's/\(.*\)\//\1\\/')
		l=$(echo $l | sed 's/frc(/frac/')
		l=$(echo $l | awk -F'\' '{ printf("%s}{%s\n", $1, $2); }')
		l=$(echo $l | sed 's/\(.*\))/\1}/')

		echo $l | sed 's/frac/\\\\frac{/g'
	done | tail -n 1
}

# This function generates "function" replacement files:
# The first argument is the input file (what needs to be parsed)
# The second argument is the output file (where to write the replacements
# The third argument is the function to look for
# The fourth argument is the format string
	# The format string follows this structure:
	# Original text:Replacement
# The fifth argument (optional) defines the field separator
function parse_fnc
{
	local o c d
	if grep -q "$3" $1; then
		echo -n '' > funcs/$2
		while IFS= read -r l; do
			o=$(echo $l | awk '{ split($0, chars, ""); o = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { o++ } } print o }')
			c=$(echo $l | awk '{ split($0, chars, ""); c = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { c++ } } print c }')
			
			if [ $c -gt $o ]; then
				d=$((c-o))
				while [ $d -gt 0 ]; do
					l=$(echo $l | sed 's/\(.*\))/\1/')
					d=$((d-1))
				done
			fi

			if [ -e $5 ]; then
				grep "$3" <<< $l | sed 's/).*//;s/'"$3"'//' | awk '{ printf('"$4"') }' >> func/$2
			else
				grep "$3" <<< $l | sed 's/).*//;s/'"$3"'//' | awk -F"$5" '{ printf('"$4"') }' >> funcs/$2
			fi
		done< <(sed 's/'"$3"'/\n'"$3"'/g' $1 | grep "$3")
	fi
}

# Cleanup on exit
# Reset IFS, remove temporary files/directories
function at_exit
{
	IFS=$oIFS
	rm -rf funcs
	rm -f lout
	rm -f tout
	rm -f *.log
	rm -f *.aux
	rm -f *.tex
	rm -f *.tmp
}

trap at_exit INT EXIT

trap 'report_err $LINENO' ERR 

# ------ SCRIPT START ------ #

# Display error message and exit if file not specified or file not found
if [ -z $1 ]; then
	echo -e "\e[0;31mMissing notes file. Aborting\e[0m"
	exit 1
elif [ ! -f $1 ]; then
	echo -e "\e[0;31mFile $1 not found. Aborting\e[0m"
	exit 1
fi

# out.tmp is a temporary file that contains most of the formatted content

# Initialize the LaTeX preamble, conditionally include based upon note contents
cat > out.tmp <<EOF
\\documentclass[letterpaper,12pt]{article}
\\usepackage[letterpaper,margin=0.75in]{geometry}
\\usepackage{xcolor}
\\usepackage{color}

\\usepackage[english]{babel}
\\usepackage[utf8x]{inputenc}
\\usepackage{fullpage}
\\usepackage{titlesec}
EOF

if grep -q 'EQUS\|SRCS' $1; then
cat >> out.tmp <<EOF
\\usepackage{tcolorbox}

\\newtcolorbox{minimal}{
	sharp corners,
	colback=white,
	colframe=black,
	notitle,
	before skip=1.5em,
	after skip=1.5em,
}

EOF
fi

if grep -q 'equ(.*)\|EQUS' $1; then
	echo "\\usepackage{mathtools}" >> out.tmp
	echo "" >> out.tmp
fi

if grep -q 'SRCS' $1; then
cat >> out.tmp <<EOF
\\usepackage{listings}

\\definecolor{mygreen}{rgb}{0,0.6,0}
\\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\\definecolor{mymauve}{rgb}{0.58,0,0.82}

\\lstset{
	backgroundcolor=\\color{white},
	basicstyle=\\footnotesize,
	breaklines=true,
	captionpos=b,
	commentstyle=\\color{mygreen},
	keywordstyle=\\color{blue},
	stringstyle=\\color{mymauve},
	showstringspaces=false,
}

EOF
fi

# Set the title format and begin the document block
echo "\\titleformat{\\section}[block]{\\color{blue}\\Large\\bfseries\\filcenter}{}{1em}{}" >> out.tmp
echo "\\begin{document}" >> out.tmp

# funcs contains files that define replacements for certain "functions" in the note file
mkdir -p funcs

# The "function" cmb() is used for defining a choose b notation
# parse_fnc finds all matching calls to a "function"
parse_fnc "$1" "cmb" 'cmb(' '"cmb(%s,%s):{%s \\\\choose %s}\n",$1,$2,$1,$2' ','

# these keep track of the number of each block type found in the notes file
lstc=0
tstc=0
equc=0
srcc=0

# These are toggled to determine when inside of a block or not
eflag=0
sflag=0
tflag=0

# The default IFS
mIFS=

# reads each line in the file
while IFS=$mIFS read -r line; do
	
	# These conditions are used to determine what block the current line is in
	# And customize the line output as necessary
	if [[ "$line" == "LSTS" ]]; then
		lstc=$((lstc+1))
		line="_LST$lstc"
	fi

	if [ $tflag -eq 2 ]; then
		tflag=1
	elif [ $tflag -eq 3 ]; then
		tflag=0
	fi

	if [[ "$line" == "TBLS"* ]]; then
		tstc=$((tstc+1))
		line="_TBL$tstc"
		tflag=2
	fi

	if [[ "$line" == "TBLE" ]]; then
		tflag=3
	fi

	if [[ "$line" == "EQUS" ]]; then
		eflag=1
		equc=$((equc+1))
		cnt=`get_line_count "$1" "EQUS" "EQUE" $equc`
	fi

	if [[ "$line" == "EQUE" ]]; then
		eflag=0
	fi

	if [[ "$line" == "SRCS:"* ]]; then
		sflag=1
	fi

	if [[ "$line" == "SRCE" ]]; then
		sflag=0
	fi
	
	# Format all { and } to \{ and \} if not in a source code block
	if [ $sflag -eq 0 ]; then
		line=$(echo $line | sed 's/{/\\{/g;s/}/\\}/g')
	fi

	# Special case: Fractions can be within fractions
	if [[ "$line" == *"frc("* ]]; then
		# The IFS needs to be a space now
		IFS=" "
		# for each "word" (field) in the line...
		for field in $line; do
			# if the field contains frc( 
			if [[ "$field" == *"frc("* ]]; then
				
				# isolate the frc() "function"
				iso=`isolate_frc "$field"`
				# format the frc() "function"
				prs=`parse_frc "$iso"`
				# and replace it within the line
				line=$(echo $line | sed "s~$iso~$prs~")
			fi
		done
	fi

	# Format the equation blocks
	if [ $eflag -eq 1 ]; then
		if [[ "$line" != "EQU"* ]]; then
			line="$line \\nonumber"
			if [ $cnt -gt 0 ]; then
				line="$line \\\\"
			fi
		fi
		cnt=$((cnt-1))
	fi
	
	# output the line to out.tmp
	if [ $tflag -eq 0 ] || [ $tflag -eq 2 ]; then
		echo $line >> out.tmp
	fi
done < $1 # $1 is the input file (argument 1 on the command line)

# If function replacements defined with parse_fnc, replace them
if [ "$(ls -A funcs)" ]; then
	while read -r fnf; do
		while IFS=":" read -r o r; do
			sed -i "s~$o~$r~" out.tmp
		done < $fnf
	done< <(ls funcs/*)
fi

# Format list blocks
IFS=
echo '' > lout
for i in `seq 1 $lstc`; do
	sed -n '/LSTS/{:a;N;/LSTE/!ba;x;s/^/x/;/^x\{'"$i"'\}$/{x;p;q};x}' $1 > lists
	echo "LSTS" >> lout
	list "lists" >> lout
	echo "LSTE" >> lout
	rm lists
done

# Format table blocks
echo '' > tout
for i in `seq 1 $tstc`; do
	sed -n '/TBLS/{:a;N;/TBLE/!ba;x;s/^/x/;/^x\{'"$i"'\}$/{x;p;q};x}' $1 > tables
	echo "TBLS" >> tout
	table "tables" >> tout
	echo "TBLE" >> tout
	rm tables
done

# Replace SRC* lines with proper LaTeX/listings beginning/end
while read -r line; do
	lang=`cut -d':' -f2 <<< $line`
	sed -i "s~$line~\\\\begin{minimal}\n\\\\begin{lstlisting}[language=$lang]~" out.tmp
done< <(grep 'SRCS' out.tmp)

sed -i "s/^SRCE/\\\\end{lstlisting}\n\\\\end{minimal}/g" out.tmp

# Replace '# Title' lines with proper LaTeX headers
while read -r line; do
	title=`cut -d' ' -f 2- <<< $line`

	title="\\\\section{$title}"
	sed -i "s~$line~$title~" out.tmp
done< <(grep '^# ' out.tmp)

# End the document block
echo "\end{document}" >> out.tmp

# Final cleanup
sed -i 's/#/\\#/g' out.tmp
sed -i '/^LST.*/d' out.tmp
sed -i '/[ \t]*\*/d' out.tmp

# Replace wrapper functions with their LaTeX equivalent
sed -i 's/equ(\([^]]*\))/\\( \1 \\)/g' out.tmp
sed -i 's/uln(\([^]]*\))/\\underline{ \1 }/g' out.tmp

# Format EQU* lines
sed -i 's/EQUS/\\begin{minimal}\n\\begin{align}/g' out.tmp
sed -i 's/EQUE/\\end{align}\n\\end{minimal}\n/g' out.tmp


# Get the file name from $1
fname="${1%.*}"
# Create the final LaTeX file by inserting formatted lists and tables where necessary
while IFS= read -r line; do

	if [[ "$line" == "_LST"* ]]; then
		gn=$(echo $line | sed 's/_LST//')
		sed -n '/LSTS/{:a;N;/LSTE/!ba;x;s/^/x/;/^x\{'"$gn"'\}$/{x;p;q};x}' lout | grep -v 'LST' >> $fname.tex
	elif [[ "$line" == "_TBL"* ]]; then
		tn=$(echo $line | sed 's/_TBL//')
		sed -n '/TBLS/{:a;N;/TBLE/!ba;x;s/^/x/;/^x\{'"$tn"'\}$/{x;p;q};x}' tout | grep -v 'TBL' >> $fname.tex
	else
		echo $line >> $fname.tex
	fi
done < out.tmp

# Generate the PDF and display success/error messages
pdflatex -interaction=nonstopmode $fname.tex
stat=$?
if [ $stat -ne 0 ]; then
	echo "notes2pdf encountered an error from pdflatex"
else
	echo -e "\e[0;32mPDF written to \e[1;32m$fname.pdf\e[0m"
fi
