#!/bin/bash

# Initialize the IFS as default and store it
IFS=
oIFS=$IFS

FNAME=$1

# Output message if verbose set
function verbout
{
	if [ $verbose -eq 1 ]; then
		echo -e "   \e[0;37m[\e[1;34m*\e[0;37m]\e[0m $1"
	fi
}

# Output line number where error occurs in script
function report_err
{
	echo -e "\e[0;31mError on line \e[1;31m$1\e[0m"
}

# This function parses and formats bullet lists
# Bullet levels are denoted with indentations
# and any text immediately following a * is treated
# as the bullet "icon" 
#	Ex: '*a.' in the note file becomes 'a.' in the PDF
function list
{
	local file="$1"
	local pi=-1
	local cnt=-1
	local psh=0

	local close=0

	local first style

	while IFS=':' read -r tnum line; do
		if [[ "$line" != "LSTS" ]] && [[ "$line" != "LSTE" ]]; then
			if [ $pi -lt $tnum ]; then
				for i in `seq 0 $pi`; do
					echo -en "\t"
				done
		
				echo "\\begin{itemize}"
				close=$((close+1))
			fi

			if [ $pi -gt $tnum ]; then
				for i in `seq 0 $pi`; do
					echo -en "\t"
				done

				if [ $psh -eq 1 ]; then
					echo -en "\t"
					psh=0
				fi

				echo "\\end{itemize}"
				close=$((close-1))
			fi
			
			first=$(echo $line | sed 's/^[ \t]*//' | cut -d' ' -f1)
			if [ ${#first} -gt 1 ]; then
				style=${first:1}
				line=$(echo $line | sed 's/\*\(.*\) /\\item['"$style"']{/;s/[[:space:]]*$//')
			else
				line=$(echo $line | sed 's/* /\\item{/;s/[[:space:]]*$//')
			fi
			line="$line}"
			
			echo -e "\t$line"

			if [ $pi -gt $tnum ] || [ $pi -eq -1 ]; then
				cnt=0
			elif [ $pi -lt $tnum ]; then
				cnt=1
			fi
	
			pi=$tnum
		fi
	done< <(awk '/LSTS/{flag=1}/LSTE/{print; flag=0}flag' $file | awk '{ match($0, /^[\t]*/); printf("%d:%s\n", RLENGTH, $0); }')

	while [ $close -gt 0 ]; do
		for i in `seq 0 $((close-2))`; do
			echo -en "\t"
		done

		echo "\\end{itemize}"

		close=$((close-1))
	done
}

# This function formats TBL blocks
# TBLS:cols:title is parsed and formatted first
# The first column is formatted as a column title row
function table
{
	local file="$1"
	local title cols
	local ctitle=0
	while IFS= read -r line; do
		if [[ "$line" == "TBLS"* ]]; then
			cols=`cut -d':' -f2 <<< $line`
			title=`cut -d':' -f3 <<< $line`
			echo "\\begin{center}"
			echo -n "\\begin{tabular}{ |"
			IFS=' '
			for i in `seq 1 $cols | tr '\n' '\ '`; do
				echo -n "c| "
			done | sed 's/ c/c/g'
			echo "}"
			if [[ ! -z $(sed 's/[ \t]//g' <<< $title) ]]; then 
				echo "\\hline"
				echo "\\multicolumn{$cols}{|c|}{$title} \\\\"
			fi
			echo "\\hline"
			ctitle=1
		elif [[ "$line" != "TBLE" ]]; then
			line=$(echo -n $line | tr -s '[\t]' '\t' | sed 's/\t/ \& /g')
			echo -e "\t$line \\\\\\\\"
			if [ $ctitle -eq 1 ]; then
				echo -e "\t\\\\hline"
				echo -e "\t\\\\hline"
				ctitle=0
			fi
		else
			echo -e "\\\\hline\n\\\\end{tabular}\n\\\\end{center}"
		fi
	done< <(awk '/TBLS/{flag=1}/TBLE/{print; flag=0}flag' $1)
}

# This function is used with equation block parsing
function get_line_count
{
	local file start end num cnt
	file="$1"
	start="$2"
	end="$3"
	num=$4

	sed -n '/'"$start"'/{:a;N;/'"$end"'/!ba;x;s/^/x/;/^x\{'"$num"'\}$/{x;p;q};x}' $file > out
	cnt=`wc -l < out`
	rm out

	echo $((cnt-2))
}

# Isolate frc() from within a line; retains +, *, / from being interpretted by sed
function isolate_frc
{
	local l="$1"
	local o c d

	if [[ "$l" != "frc("* ]]; then
		l=$(echo $l | sed 's/frc(/ frc(/' | cut -d' ' -f 2-)
	fi

	IFS=
	l=$(echo $l | sed 's/ \+/\+/;s/\+ /\+/;s/\+/_plus/')
	l=$(echo $l | sed 's/ \*/\*/;s/\* /\*/;s/\*/_times/')
	l=$(echo $l | sed 's/ \//\//;s/\/ /\//;s/\//_divide/')

	o=$(echo $l | awk '{ split($0, chars, ""); o = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { o++ } } print o }')
	c=$(echo $l | awk '{ split($0, chars, ""); c = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { c++ } } print c }')

	if [ $c -gt $o ]; then
		d=$((c-o))
		while [ $d -gt 0 ]; do
			l=$(echo $l | sed 's/\(.*\))/\1/')
			d=$((d-1))
		done
	fi
	
	IFS=
	l=$(echo $l | sed 's/_plus/\+/')
	l=$(echo $l | sed 's/_times/\*/')
	l=$(echo $l | sed 's/_divide/\//')
	echo $l
}

# Parses through frc() and formats all frc() into proper LaTeX
function parse_frc
{
	local l="$1"

	while [[ "$l" == *"/"* ]]; do
		l=$(echo $l | sed 's/\(.*\)\//\1\\/')
		l=$(echo $l | sed 's/frc(/frac/')
		l=$(echo $l | awk -F'\' '{ printf("%s}{%s\n", $1, $2); }')
		l=$(echo $l | sed 's/\(.*\))/\1}/')

		echo $l | sed 's/frac/\\\\frac{/g'
	done | tail -n 1
}

# This function generates "function" replacement files:
# The first argument is the input file (what needs to be parsed)
# The second argument is the output file (where to write the replacements
# The third argument is the function to look for
# The fourth argument is the format string
	# The format string follows this structure:
	# Original text:Replacement
# The fifth argument (optional) defines the field separator
function parse_fnc
{
	local o c d
	verbout "Generating replacements for $3)"
	if grep -q "$3" $1; then
		echo -n '' > funcs/$2
		while IFS= read -r l; do
			o=$(echo $l | awk '{ split($0, chars, ""); o = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { o++ } } print o }')
			c=$(echo $l | awk '{ split($0, chars, ""); c = 0; for (i=1;i<=length($0);i++) { if (chars[i] == "(") { c++ } } print c }')
			
			if [ $c -gt $o ]; then
				d=$((c-o))
				while [ $d -gt 0 ]; do
					l=$(echo $l | sed 's/\(.*\))/\1/')
					d=$((d-1))
				done
			fi

			if [ -e $5 ]; then
				grep "$3" <<< $l | sed 's/).*//;s/'"$3"'//' | awk '{ printf('"$4"') }' >> func/$2
			else
				grep "$3" <<< $l | sed 's/).*//;s/'"$3"'//' | awk -F"$5" '{ printf('"$4"') }' >> funcs/$2
			fi
		done< <(sed 's/'"$3"'/\n'"$3"'/g' $1 | grep "$3")
	fi
}

# Show formatted help message
function showhelp
{
	echo "Usage: notes2pdf <switch(es)> <file>"
	echo -e "\n \e[4mPossible switches:\e[0m\n"
	tr -s '\t' '\t' <<< '
-h, --help		Display this help
-v, --verbose	Verbose output
-d, --debug		Retain log and tex files for debugging  
-o, --output <filename>	Specify the name of the PDF file
-p, --preview	Show a preview of the PDF on completion
' | sed 's/\t/: :/g' | column -s ':' -t | sed 's/^/  /g'
	echo
}

# Cleanup on exit
# Reset IFS, remove temporary files/directories
function at_exit
{
	IFS=$oIFS
	rm -rf funcs
	rm -f lout
	rm -f tout
	if [ $error -eq 0 ]; then
		rm -f *.log
	fi
	rm -f *.aux
	if [ $debug -eq 0 ]; then
		rm -f *.tex
	fi
	rm -f *.tmp
}

trap at_exit INT EXIT

trap 'report_err $LINENO' ERR 

##### ------ SCRIPT START ------ #####

debug=0
output=""
error=0
preview=0
_help=0
verbose=0

rm -f *.tex
rm -f *.log

# set help switch to 1 if no args passed or arg1 = -h or --help
if [ $# -gt 0 ]; then
	if [[ "$1" != "-h" ]] && [[ "$1" != "--help" ]]; then
		# Iterate through switches
		while [ $# -gt 1 ]; do
			case "$1" in
				-d)
					;&
				--debug)
					debug=1
					;;
				-v)
					;&
				--verbose)
					verbose=1
					;;
				-o)
					;&
				--output)
					if [[ "$2" == *".notes" ]] || [[ "$2" == "-"* ]]; then
						echo "Missing filename argument for '$1'. Aborting."
						exit 1
					fi
					output="${2%.*}"
					shift
					;;
				-p)
					;&
				--preview)
					preview=1
					;;
				-h)
					;&
				--help)
					_help=1
					;;
				*)
					echo -e "\e[0;37m[\e[1;33m-\e[0;37m]\e[0m Unknown option '$1'. Ignoring"
					;;
			esac
			shift
		done
	else
		_help=1
	fi
else
	echo -e "Missing arguments\n"
	_help=1
fi

# if help switch set, show help
if [ $_help -eq 1 ]; then
	showhelp
	exit 0
fi

# Output message and exit if file not found, otherwise set FNAME
if [ ! -f ${1%.*}.notes ]; then
	echo -e "\e[0;37m[\e[1;31m!\e[0;37m]\e[0m File not found. Aborting."
	exit 1
else
	FNAME="$1"
fi

# Output message based on debug switch
if [ $debug -eq 1 ]; then
	echo -e "\e[0;37m[\e[1;32mi\e[0;37m]\e[0m Starting notes2pdf in debug mode"
	echo -e "   \e[0;37m[\e[1;36m+\e[0;37m]\e[0m Debug information will be stored in ${FNAME%.*}.log"
	echo -e "   \e[0;37m[\e[1;36m+\e[0;37m]\e[0m ${FNAME%.*}.log corresponds with ${FNAME%.*}.tex"
else
	echo -e "\e[0;37m[\e[1;32mi\e[0;37m]\e[0m Starting notes2pdf"
fi

# output formatting
if [ $verbose -eq 1 ]; then
	echo
fi

# output message if output file specified via output switch
if [ ! -z $output ]; then
	echo -e "\e[0;37m[\e[1;32mi\e[0;37m]\e[0m $FNAME will be written to $output.pdf"
fi

# out.tmp is a temporary file that contains most of the formatted content

# Initialize the LaTeX preamble, conditionally include based upon note contents
verbout "Defining template defaults"
cat > out.tmp <<EOF
\\documentclass[letterpaper,12pt]{article}
\\usepackage[letterpaper,margin=0.75in]{geometry}
\\usepackage{xcolor}
\\usepackage{color}

\\usepackage[english]{babel}
\\usepackage[utf8x]{inputenc}
\\usepackage{fullpage}
\\usepackage{titlesec}
EOF

if grep -q 'EQUS\|SRCS' $FNAME; then
	verbout "Found Equation/Source block(s) in $FNAME"
	verbout "Updating template"
cat >> out.tmp <<EOF
\\usepackage{tcolorbox}

\\newtcolorbox{minimal}{
	sharp corners,
	colback=white,
	colframe=black,
	notitle,
	before skip=1.5em,
	after skip=1.5em,
}

EOF
fi

if grep -q 'equ(.*)\|EQUS' $FNAME; then
	verbout "Found Equation(s) in $FNAME"
	verbout "Updating template"
	echo "\\usepackage{mathtools}" >> out.tmp
	echo "" >> out.tmp
fi

if grep -q 'SRCS' $FNAME; then
	verbout "Found Source block(s) in $FNAME"
	verbout "Updating template"
cat >> out.tmp <<EOF
\\usepackage{listings}

\\definecolor{mygreen}{rgb}{0,0.6,0}
\\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\\definecolor{mymauve}{rgb}{0.58,0,0.82}

\\lstset{
	backgroundcolor=\\color{white},
	basicstyle=\\footnotesize,
	breaklines=true,
	captionpos=b,
	commentstyle=\\color{mygreen},
	keywordstyle=\\color{blue},
	stringstyle=\\color{mymauve},
	showstringspaces=false,
}

EOF
fi

verbout "Initializing Document data"
# Set the title format and begin the document block
echo "\\titleformat{\\section}[block]{\\color{blue}\\Large\\bfseries\\filcenter}{}{1em}{}" >> out.tmp
echo "\\begin{document}" >> out.tmp

# funcs contains files that define replacements for certain "functions" in the note file
mkdir -p funcs

# The "function" cmb() is used for defining a choose b notation
# parse_fnc finds all matching calls to a "function"
parse_fnc "$FNAME" "cmb" 'cmb(' '"cmb(%s,%s):{%s \\\\choose %s}\n",$1,$2,$1,$2' ','

# these keep track of the number of each block type found in the notes file
lstc=0
tstc=0
equc=0
srcc=0

# These are toggled to determine when inside of a block or not
eflag=0
sflag=0
tflag=0

# The default IFS
mIFS=

# reads each line in the file
while IFS=$mIFS read -r line; do
	
	# These conditions are used to determine what block the current line is in
	# And customize the line output as necessary
	if [[ "$line" == "LSTS" ]]; then
		verbout "Start List block"
		lstc=$((lstc+1))
		line="_LST$lstc"
	fi

	if [ $tflag -eq 2 ]; then
		tflag=1
	elif [ $tflag -eq 3 ]; then
		tflag=0
	fi

	if [[ "$line" == "TBLS"* ]]; then
		verbout "Start Table block"
		tstc=$((tstc+1))
		line="_TBL$tstc"
		tflag=2
	fi

	if [[ "$line" == "TBLE" ]]; then
		verbout "End Table block"
		tflag=3
	fi

	if [[ "$line" == "EQUS" ]]; then
		verbout "Start Equation block"
		eflag=1
		equc=$((equc+1))
		cnt=`get_line_count "$FNAME" "EQUS" "EQUE" $equc`
	fi

	if [[ "$line" == "EQUE" ]]; then
		verbout "End Equation block"
		eflag=0
	fi

	if [[ "$line" == "SRCS:"* ]]; then
		verbout "Start Source block"
		sflag=1
	fi

	if [[ "$line" == "SRCE" ]]; then
		verbout "End Source block"
		sflag=0
	fi
	
	# Format all { and } to \{ and \} if not in a source code block
	if [ $sflag -eq 0 ]; then
		line=$(echo $line | sed 's/{/\\{/g;s/}/\\}/g')
	fi

	# Special case: Fractions can be within fractions
	if [[ "$line" == *"frc("* ]]; then
		verbout "Fraction(s) found. Starting fraction parse task"
		# The IFS needs to be a space now
		IFS=" "
		# for each "word" (field) in the line...
		for field in $line; do
			# if the field contains frc( 
			if [[ "$field" == *"frc("* ]]; then
				
				# isolate the frc() "function"
				iso=`isolate_frc "$field"`
				# format the frc() "function"
				prs=`parse_frc "$iso"`
				# and replace it within the line
				line=$(echo $line | sed "s~$iso~$prs~")
			fi
		done
		verbout "Fraction parse task finished"
	fi

	# Format the equation blocks
	if [ $eflag -eq 1 ]; then
		verbout "Inside Equation block, formatting content"
		if [[ "$line" != "EQU"* ]]; then
			line="$line \\nonumber"
			if [ $cnt -gt 0 ]; then
				line="$line \\\\"
			fi
		fi
		cnt=$((cnt-1))
	fi
	
	# output the line to out.tmp
	if [ $tflag -eq 0 ] || [ $tflag -eq 2 ]; then
		echo $line >> out.tmp
	fi
done < $FNAME # FNAME is the input file)

# If function replacements defined with parse_fnc, replace them
if [ "$(ls -A funcs)" ]; then
	while read -r fnf; do
		while IFS=":" read -r o r; do
			sed -i "s~$o~$r~" out.tmp
		done < $fnf
	done< <(ls funcs/*)
fi

# Format list blocks
if grep -q 'LSTS' $FNAME; then
	verbout "Formatting List block(s)"
	IFS=
	echo '' > lout
	for i in `seq 1 $lstc`; do
		sed -n '/LSTS/{:a;N;/LSTE/!ba;x;s/^/x/;/^x\{'"$i"'\}$/{x;p;q};x}' $FNAME > lists
		echo "LSTS" >> lout
		list "lists" >> lout
		echo "LSTE" >> lout
		rm lists
	done
	verbout "Formatted List blocks"
fi

# Format table blocks
if grep -q 'TBLS' $FNAME; then
	verbout "Formatting Table block(s)"
	echo '' > tout
	for i in `seq 1 $tstc`; do
		sed -n '/TBLS/{:a;N;/TBLE/!ba;x;s/^/x/;/^x\{'"$i"'\}$/{x;p;q};x}' $FNAME > tables
		echo "TBLS" >> tout
		table "tables" >> tout
		echo "TBLE" >> tout
		rm tables
	done
fi

# Replace SRC* lines with proper LaTeX/listings beginning/end
while read -r line; do
	lang=`cut -d':' -f2 <<< $line`
	sed -i "s~$line~\\\\begin{minimal}\n\\\\begin{lstlisting}[language=$lang]~" out.tmp
done< <(grep 'SRCS' out.tmp)

sed -i "s/^SRCE/\\\\end{lstlisting}\n\\\\end{minimal}/g" out.tmp

verbout "Formatting Title lines"
# Replace '# Title' lines with proper LaTeX headers
while read -r line; do
	title=`cut -d' ' -f 2- <<< $line`

	title="\\\\section{$title}"
	sed -i "s~$line~$title~" out.tmp
done< <(grep '^# ' out.tmp)

# End the document block
echo "\end{document}" >> out.tmp

# Final cleanup
sed -i 's/#/\\#/g' out.tmp
sed -i '/^LST.*/d' out.tmp
sed -i '/[ \t]*\*/d' out.tmp

verbout "Formatting wrapper function(s)"
# Replace wrapper functions with their LaTeX equivalent
sed -i 's/equ(\([^]]*\))/\\( \1 \\)/g' out.tmp
sed -i 's/uln(\([^]]*\))/\\underline{ \1 }/g' out.tmp

# Format EQU* lines
sed -i 's/EQUS/\\begin{minimal}\n\\begin{align}/g' out.tmp
sed -i 's/EQUE/\\end{align}\n\\end{minimal}\n/g' out.tmp

# Create the final LaTeX file by inserting formatted lists and tables where necessary
FNAME="${FNAME%.*}"
verbout "Compiling formatted content to $FNAME.tex"
while IFS= read -r line; do

	if [[ "$line" == "_LST"* ]]; then
		verbout "List block found. Inserting formatted content"
		gn=$(echo $line | sed 's/_LST//')
		sed -n '/LSTS/{:a;N;/LSTE/!ba;x;s/^/x/;/^x\{'"$gn"'\}$/{x;p;q};x}' lout | grep -v 'LST' >> $FNAME.tex
	elif [[ "$line" == "_TBL"* ]]; then
		verbout "Table block found. Inserting formatted content"
		tn=$(echo $line | sed 's/_TBL//')
		sed -n '/TBLS/{:a;N;/TBLE/!ba;x;s/^/x/;/^x\{'"$tn"'\}$/{x;p;q};x}' tout | grep -v 'TBL' >> $FNAME.tex
	else
		echo $line >> $FNAME.tex
	fi
done < out.tmp

# Generate the PDF and display success/error messages
verbout "Attempting to convert $FNAME.tex to PDF"
pdflatex -interaction=nonstopmode -file-line-error $FNAME.tex > /dev/null 

stat=$?
if [ $stat -ne 0 ]; then
	echo
	echo -e "\e[0;37m[\e[1;31m!\e[0;37m]\e[0m notes2pdf encountered an error from pdflatex."
	if [ $debug -eq 0 ]; then
		echo -e "\t\e[0;37m\e[1;33m?\e[0;37m]\e[0m Try running notes2pdf --debug $FNAME.notes"
	fi
	error=1
else
	if [ ! -z $output ]; then
		verbout "Saving PDF as ${output%.*}.pdf"
		mv $FNAME.pdf $output
		FNAME="${output%.*}"
	fi
	echo
	echo -e "\e[0;37m[\e[1;32mi\e[0;37m]\e[0m PDF written to $FNAME.pdf"
fi

if [ $preview -eq 1 ]; then
	verbout "Determining OS"
	os=""
	if grep -qE "(Microsoft|WSL)" /proc/version &> /dev/null; then
		os="win"
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		os="osx"
	else
		os="nix"
	fi
	verbout "OS: $os"
	echo
	if [ $error -eq 0 ]; then
		echo -e "\e[0;37m[\e[1;32mi\e[0;37m]\e[0m Opening preview of $FNAME.pdf" 
		# This is not tested
		if [[ "$os" == "win" ]]; then
			cmd.exe /C start $FNAME.pdf
		elif [[ "$os" == "osx" ]]; then
			open $FNAME.pdf
		elif [[ "$os" == "nix" ]]; then
			xdg-open $FNAME.pdf > /dev/null 2> /dev/null
		fi
	else
		echo -e "\e[0;37m[\e[1;31m!\e[0;37m]\e[0m Error(s) exist in $FNAME.notes. Preview unavailable." 
	fi
fi
